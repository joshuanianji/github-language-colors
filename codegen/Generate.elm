module Generate exposing (main)

{-| Generate src/GithuhbColors.elm
-}

import Elm
import Elm.Annotation as Type
import Flags exposing (Flag, FlagColor, WithName, WithProcessed)
import Gen.CodeGen.Generate as Generate
import Gen.Color
import Gen.Element
import Json.Decode exposing (Value)
import Util
import Gen.Dict


main : Program Value () ()
main =
    Generate.fromJson Flags.decoder generate


generate : Flag -> List Elm.File
generate flag =
    let
        colorTypeDeclaration =
            Elm.alias "Color" colorTypeRecord
                |> Elm.exposeWith
                    { exposeConstructor = False
                    , group = Just "Color Type"
                    }
                |> Elm.withDocumentation
                    """Each color exposes the following fields:
- `elmui` - The color as an [elm-ui](https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/) `Element.Color`
- `color` - The color as an [elm-color](https://package.elm-lang.org/packages/avh4/elm-color/latest/) `Color.Color`
- `hex` - The color as a hex string
- `rgb` - The color as an RGB triple
- `hasColor` - A boolean indicating whether the language has a color on Github, or if it's been defaulted to "#ccc"

The `elmui` and `color` fields are provided for convenience, but you can also use the `hex` and `rgb` fields to construct your own color values."""

        colorDeclarations =
            List.map generateColorDecl flag
    in
    [ Elm.fileWith [ "GithubColors" ]
        { docs = \l -> topLevelDoc :: List.map Elm.docs l
        , aliases = []
        }
        (colorTypeDeclaration :: (generateLanguageDict flag) :: colorDeclarations)
    ]



-- This is added above the generated documentation


topLevelDoc : String
topLevelDoc =
    """This module exposes the color values for all supported languages on Github. Color data is taken from [ozh/github-colors](https://github.com/ozh/github-colors).

**NOTE:** This is an autogenerated file using [mdgriffith/elm-codegen](https://github.com/mdgriffith/elm-codegen). 
"""


colorTypeRecord : Type.Annotation
colorTypeRecord =
    Type.record
        [ ( "elmui", Gen.Element.annotation_.color )
        , ( "color", Gen.Color.annotation_.color )
        , ( "hex", Type.string )
        , ( "rgb", Type.triple Type.int Type.int Type.int )
        , ( "hasColor", Type.bool )
        ]


generateColorDecl : WithProcessed (WithName FlagColor) -> Elm.Declaration
generateColorDecl color =
    let
        ( r, g, b ) =
            color.processed.rgb
    in
    Elm.declaration color.processed.name
        (Elm.record
            [ ( "elmui", Gen.Element.rgb255 r g b )
            , ( "color", Gen.Color.rgb255 r g b )
            , ( "hex", Elm.string color.processed.hex )
            , ( "rgb", Elm.triple (Elm.int r) (Elm.int g) (Elm.int b) )
            , ( "hasColor", Elm.bool <| Util.isJust color.color )
            ]
            |> Elm.withType colorType
        )
        |> Elm.withDocumentation ("Github language color for '" ++ color.name ++ "'")
        |> Elm.exposeWith
            { exposeConstructor = False
            , group = Just "Language Colors"
            }


generateLanguageDict : Flag -> Elm.Declaration
generateLanguageDict colors = 
    let
        languagesList =
            List.map (\color -> Elm.tuple (Elm.string color.processed.name) (Elm.val color.processed.name)) colors
    in 
    Gen.Dict.fromList languagesList
        |> Elm.withType (Gen.Dict.annotation_.dict Type.string colorType)
        |> Elm.declaration "languageDict"
        |> Elm.withDocumentation ("Maps language string names to their respective color values.\n\nAccess it by `Dict.get \"language\" languageDict`. which returns a `Maybe Color` value.")
        |> Elm.expose


colorType : Type.Annotation
colorType = 
    Type.alias [] "Color" [] Type.string
